<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Types and Extensions &mdash; Fabric Engine 2.3.0 Unofficial Documentation (ja)</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Fabric Engine 2.3.0 Unofficial Documentation (ja)" href="../index.html" />
    <link rel="up" title="エクステンション・オーサリングガイド" href="index.html" />
    <link rel="next" title="Calling Convention for Exported Functions" href="cconv.html" />
    <link rel="prev" title="The kl2edk Utility" href="kl2edk.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="cconv.html" title="Calling Convention for Exported Functions"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="kl2edk.html" title="The kl2edk Utility"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Fabric Engine 2.3.0 Unofficial Documentation (ja)</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">エクステンション・オーサリングガイド</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="types-and-extensions">
<span id="eag-types"></span><h1>Types and Extensions<a class="headerlink" href="#types-and-extensions" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>In this section we learn more about the relationship between types in KL and corresponding types in extensions.</p>
<p>The header file generated by <strong class="command">kl2edk</strong> as well as the <code class="file docutils literal"><span class="pre">FabricEDK.h</span></code> header file it includes provide definitions for the built-in KL types, any types defined by the extension, and any types defined by other extensions required by the extension.  All of these types are defined in the <code class="code docutils literal"><span class="pre">Fabric::EDK::KL</span></code> namespace.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">For brevity, all types in this section will be referred to without the <code class="docutils literal"><span class="pre">Fabirc::EDK::</span></code> namespace prefix as if the <code class="code docutils literal"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">Fabric::EDK;</span></code> directive had been issued.</p>
</div>
<div class="section" id="simple-types">
<span id="types-simple"></span><h2>Simple Types<a class="headerlink" href="#simple-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The simple types are all simply aliases for existing C++ types.</p>
<p>When a simple type is passed as an <code class="code docutils literal"><span class="pre">in</span></code> parameter from KL, the corresponding parameter in C++ should be a &#8220;pass-by-value&#8221;, ie. without the <code class="docutils literal"><span class="pre">&amp;</span></code> pass-by-reference symbol.  Similarly, an extension function that returns a value that is a simple type should just return the value directly rather than use a &#8220;hidden return parameter&#8221;.  See <a class="reference internal" href="cconv.html#cconv-simple"><span class="std std-ref">Calling Convention for Simple Types</span></a> for more information about the calling convention for simple types.</p>
<p><code class="docutils literal"><span class="pre">KL::Boolean</span></code></p>
<blockquote>
<div>The KL <code class="docutils literal"><span class="pre">Boolean</span></code> type.  You can assign the C++ constants <code class="docutils literal"><span class="pre">true</span></code> and <code class="docutils literal"><span class="pre">false</span></code> to expressions of this type.</div></blockquote>
<p><code class="docutils literal"><span class="pre">KL::UInt8</span></code>, <code class="docutils literal"><span class="pre">KL::SInt8</span></code>, <code class="docutils literal"><span class="pre">KL::UInt16</span></code>, <code class="docutils literal"><span class="pre">KL::SInt16</span></code>, <code class="docutils literal"><span class="pre">KL::UInt32</span></code>, <code class="docutils literal"><span class="pre">KL::SInt32</span></code>, <code class="docutils literal"><span class="pre">KL::UInt64</span></code>, <code class="docutils literal"><span class="pre">KL::SInt64</span></code></p>
<blockquote>
<div>The KL integer types; equivalent to the KL types of the same name.</div></blockquote>
<p><code class="docutils literal"><span class="pre">KL::Float32</span></code>, <code class="docutils literal"><span class="pre">KL::Float64</span></code></p>
<blockquote>
<div>The KL floating-point types; equivalent to the KL types of the same name.</div></blockquote>
<p><code class="docutils literal"><span class="pre">KL::Byte</span></code>, <code class="docutils literal"><span class="pre">KL::Integer</span></code>, <code class="docutils literal"><span class="pre">KL::Index</span></code>, <code class="docutils literal"><span class="pre">KL::Size</span></code>, <code class="docutils literal"><span class="pre">KL::Scalar</span></code></p>
<blockquote>
<div>KL built-in type aliases; they alias the same type as in the KL language.</div></blockquote>
<p><code class="docutils literal"><span class="pre">KL::Data</span></code></p>
<blockquote>
<div>The KL <code class="code docutils literal"><span class="pre">Data</span></code> type.  This is simply a type alias for <code class="code docutils literal"><span class="pre">void</span> <span class="pre">*</span></code>; however, there is a <code class="code docutils literal"><span class="pre">KL::DataWrapper</span></code> template provided by <code class="file docutils literal"><span class="pre">FabricEDK.h</span></code> that makes it much easier to work with these pointers; see <a class="reference internal" href="#eag-types-data"><span class="std std-ref">The KL::DataWrapper&lt;Ty&gt; and KL::ConstDataWrapper&lt;Ty&gt; Templates</span></a> for more information.</div></blockquote>
<div class="section" id="equivalences-for-simple-types">
<span id="types-simple-equivalent"></span><h3>Equivalences for Simple Types<a class="headerlink" href="#equivalences-for-simple-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Since simple types are just aliases for preexisting C++ types, you can use
corresponding C++ types in place of them wherever convenient.  The following table shows equivalent C++ types for each KL simple type:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>KL Type</td>
<td>Equivalent C++ type(s)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">KL::Boolean</span></code></td>
<td><code class="docutils literal"><span class="pre">bool</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">KL::UInt8</span></code></td>
<td><code class="docutils literal"><span class="pre">uint8_t</span></code>, <code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">KL::UInt16</span></code></td>
<td><code class="docutils literal"><span class="pre">uint16_t</span></code>, <code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">KL::UInt32</span></code></td>
<td><code class="docutils literal"><span class="pre">uint32_t</span></code>, <code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">KL::UInt64</span></code></td>
<td><code class="docutils literal"><span class="pre">uint64_t</span></code>, <code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">KL::SInt8</span></code></td>
<td><code class="docutils literal"><span class="pre">int8_t</span></code>, <code class="docutils literal"><span class="pre">char</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">KL::SInt16</span></code></td>
<td><code class="docutils literal"><span class="pre">int16_t</span></code>, <code class="docutils literal"><span class="pre">short</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">KL::SInt32</span></code></td>
<td><code class="docutils literal"><span class="pre">int32_t</span></code>, <code class="docutils literal"><span class="pre">int</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">KL::SInt64</span></code></td>
<td><code class="docutils literal"><span class="pre">int64_t</span></code>, <code class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">KL::Float32</span></code></td>
<td><code class="docutils literal"><span class="pre">float</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">KL::Float64</span></code></td>
<td><code class="docutils literal"><span class="pre">double</span></code></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="the-kl-datawrapper-ty-and-kl-constdatawrapper-ty-templates">
<span id="eag-types-data"></span><h3>The <code class="samp docutils literal"><span class="pre">KL::DataWrapper&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code> and <code class="samp docutils literal"><span class="pre">KL::ConstDataWrapper&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code> Templates<a class="headerlink" href="#the-kl-datawrapper-ty-and-kl-constdatawrapper-ty-templates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In order to simplify use of the <code class="code docutils literal"><span class="pre">KL::Data</span></code> type, <code class="file docutils literal"><span class="pre">FabricEDK.h</span></code> provides the templates <code class="samp docutils literal"><span class="pre">KL::DataWrapper&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code> <code class="samp docutils literal"><span class="pre">KL::ConstDataWrapper&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code> that allows you to treat a value of type <code class="code docutils literal"><span class="pre">KL::Data</span></code> as if it were a pointer to a more complex type.  <code class="samp docutils literal"><span class="pre">KL::DataWrapper&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code> allows modification of the resulting complex type whereas <code class="samp docutils literal"><span class="pre">KL::ConstDataWrapper&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code> allows it only to be read.  The best explanation is through an example:</p>
<div class="highlight-C++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">SomeMoreComplexStruct</span> <span class="p">{</span>
  <span class="n">InternalValue</span> <span class="n">value</span><span class="p">;</span>
  <span class="c1">// ....</span>
<span class="p">};</span>

<span class="n">FABRIC_EDK_EXPORT</span> <span class="kt">void</span> <span class="nf">MyFunc</span><span class="p">(</span> <span class="n">Fabric</span><span class="o">::</span><span class="n">EDK</span><span class="o">::</span><span class="n">KL</span><span class="o">::</span><span class="n">Data</span><span class="o">::</span><span class="n">IOParam</span> <span class="n">data</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">Fabric</span><span class="o">::</span><span class="n">EDK</span><span class="o">::</span><span class="n">KL</span><span class="o">::</span><span class="n">DataWrapper</span><span class="o">&lt;</span><span class="n">SomeMoreComplexStruct</span><span class="o">&gt;</span> <span class="n">complexStruct</span><span class="p">(</span> <span class="n">data</span> <span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">complexStruct</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Note that this assignment actually changes the referenced</span>
    <span class="n">complexStruct</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SomeMoreComplexStruct</span><span class="p">;</span>
    <span class="n">complexStruct</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="c1">// ... whatever</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="complex-types">
<span id="types-complex"></span><h2>Complex Types<a class="headerlink" href="#complex-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The complex types do not correspond directly to an existing C++ type, but instead have a complex representation as a C++ class or template in header file generated by <strong class="command">kl2edk</strong> or the <code class="file docutils literal"><span class="pre">FabricEDK.h</span></code> header file.</p>
<p>Complex types must always be passed by reference in C++ functions corresponding to KL functions, even when they are <code class="code docutils literal"><span class="pre">in</span></code> parameters in KL; similarly, they must always be returned through a &#8220;hidden return parameter&#8221;.  This is usually done using the <code class="code docutils literal"><span class="pre">::INParam</span></code> and <code class="code docutils literal"><span class="pre">::Result</span></code> typedefs.  For more information, see <a class="reference internal" href="cconv.html#cconv-complex"><span class="std std-ref">Calling Convention for Complex Types</span></a>.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">Unlike KL (in guarded mode), there are generally no checks for array indices or other lookups when using complex types.  It is the responsibility of the programmer to ensure that these operations are within bounds.</p>
</div>
<div class="section" id="kl-string">
<span id="types-string"></span><h3><code class="code docutils literal"><span class="pre">KL::String</span></code><a class="headerlink" href="#kl-string" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Provides the functionality of the KL <code class="docutils literal"><span class="pre">String</span></code> type.  It supports the usual empty constructor, copy constructor, and assignment operator, as well as following methods:</p>
<dl class="function">
<dt id="_CPPv2NK2KL6String5c_strEv">
<span id="KL::String::c_strC"></span><em class="property">const</em> char *<code class="descclassname">KL::String::</code><code class="descname">c_str</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK2KL6String5c_strEv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns the string contents as a C-style null-terminated string.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK2KL6String4dataEv">
<span id="KL::String::dataC"></span><em class="property">const</em> char *<code class="descclassname">KL::String::</code><code class="descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK2KL6String4dataEv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns the string contents as a raw pointer to character data.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK2KL6String6lengthEv">
<span id="KL::String::lengthC"></span>uint32_t <code class="descclassname">KL::String::</code><code class="descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK2KL6String6lengthEv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns the string contents as a raw pointer to character data.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N2KL6String6appendEc">
<span id="KL::String::append__c"></span>void <code class="descclassname">KL::String::</code><code class="descname">append</code><span class="sig-paren">(</span>char <em>ch</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N2KL6String6appendEc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Appends a character to the string.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N2KL6StringpLEc">
<span id="KL::String::add-assign-operator__c"></span>void <code class="descclassname">KL::String::</code><code class="descname">operator+=</code><span class="sig-paren">(</span>char <em>ch</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N2KL6StringpLEc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Alias for <code class="docutils literal"><span class="pre">void</span> <span class="pre">KL::String::append(char</span> <span class="pre">ch)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N2KL6String6appendEPc8uint32_t">
<span id="KL::String::append__cCP.uint32_t"></span>void <code class="descclassname">KL::String::</code><code class="descname">append</code><span class="sig-paren">(</span>char <em class="property">const</em> *<em>data</em>, uint32_t <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N2KL6String6appendEPc8uint32_t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Appends another string given as a raw character pointer and a length.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N2KL6String6appendEPc">
<span id="KL::String::append__cCP"></span>void <code class="descclassname">KL::String::</code><code class="descname">append</code><span class="sig-paren">(</span>char <em class="property">const</em> *<em>cStr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N2KL6String6appendEPc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Appends another string given as a C-style null-terminate string.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N2KL6StringpLEPc">
<span id="KL::String::add-assign-operator__cCP"></span>void <code class="descclassname">KL::String::</code><code class="descname">operator+=</code><span class="sig-paren">(</span>char <em class="property">const</em> *<em>cStr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N2KL6StringpLEPc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Alias for <code class="docutils literal"><span class="pre">void</span> <span class="pre">KL::String::append(char</span> <span class="pre">const</span> <span class="pre">*cStr)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N2KL6String6appendERN2KL6StringE">
<span id="KL::String::append__KL::StringCR"></span>void <code class="descclassname">KL::String::</code><code class="descname">append</code><span class="sig-paren">(</span>KL::String <em class="property">const</em> &amp;<em>that</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N2KL6String6appendERN2KL6StringE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Appends another <code class="code docutils literal"><span class="pre">KL::String</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N2KL6StringpLERN2KL6StringE">
<span id="KL::String::add-assign-operator__KL::StringCR"></span>void <code class="descclassname">KL::String::</code><code class="descname">operator+=</code><span class="sig-paren">(</span>KL::String <em class="property">const</em> &amp;<em>that</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N2KL6StringpLERN2KL6StringE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Alias for <code class="docutils literal"><span class="pre">void</span> <span class="pre">KL::String::append(KL::String</span> <span class="pre">const</span> <span class="pre">&amp;that)</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="kl-variablearray-ty">
<span id="types-container"></span><h3><code class="samp docutils literal"><span class="pre">KL::VariableArray&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code><a class="headerlink" href="#kl-variablearray-ty" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Provides the functionality of a variable array of the type <code class="samp docutils literal"><em><span class="pre">Ty</span></em></code>, which must itself be a KL type.  It supports an empty constructor that constructs an empty array, a copy constructor and assignment operator that take a reference to the contents of the other array, as well as the following methods:</p>
<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IENK2KL13VariableArrayI2TyE4sizeEv">
uint32_t <code class="descclassname">KL::VariableArray&lt;Ty&gt;::</code><code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2IENK2KL13VariableArrayI2TyE4sizeEv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns the size (length) of the array.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IEN2KL13VariableArrayI2TyE6resizeE8uint32_t">
void <code class="descclassname">KL::VariableArray&lt;Ty&gt;::</code><code class="descname">resize</code><span class="sig-paren">(</span>uint32_t <em>newSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2IEN2KL13VariableArrayI2TyE6resizeE8uint32_t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Resize the array.  The new elements (if any) will be initialized using the constructor for the given type.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IEN2KL13VariableArrayI2TyE9push_backER2Ty">
void <code class="descclassname">KL::VariableArray&lt;Ty&gt;::</code><code class="descname">push_back</code><span class="sig-paren">(</span>Ty <em class="property">const</em> &amp;<em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2IEN2KL13VariableArrayI2TyE9push_backER2Ty" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Append an element to the end of the array</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IENK2KL13VariableArrayI2TyEixE8uint32_t">
Ty <em class="property">const</em> &amp;<code class="descclassname">KL::VariableArray&lt;Ty&gt;::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint32_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2IENK2KL13VariableArrayI2TyEixE8uint32_t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The read-only array indexing operator.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IEN2KL13VariableArrayI2TyEixE8uint32_t">
Ty &amp;<code class="descclassname">KL::VariableArray&lt;Ty&gt;::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint32_t <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2IEN2KL13VariableArrayI2TyEixE8uint32_t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The read-write array indexing operator.  It returns a modifiable reference to the given element of the array.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Unlike KL, there is no checks for array indices when indexing into an array.  It is the responsibility of the programmer to ensure that the array index is within bounds.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">References returned from the array indexing operators should be considered temporary and should not be stored in other variables.  Calling the <code class="docutils literal"><span class="pre">resize</span></code> method on a variable array may cause references to become invalid.</p>
</div>
</div>
<div class="section" id="kl-fixedarray-ty-size">
<h3><code class="samp docutils literal"><span class="pre">KL::FixedArray&lt;</span><em><span class="pre">Ty</span></em><span class="pre">,</span> <em><span class="pre">size</span></em><span class="pre">&gt;</span></code><a class="headerlink" href="#kl-fixedarray-ty-size" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Provides the functionality of a KL fixed array of the type <code class="samp docutils literal"><em><span class="pre">Ty</span></em></code>, which must itself be a KL type, of size :samp:{size} which must be an unsigned integer.  It proves the usual empty and copy constructors and assignment operators.  It provides the following specialized constructors and methods:</p>
<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IENK2KL13ExternalArrayI2TyEixE8uint32_t">
Ty <em class="property">const</em> &amp;<code class="descclassname">KL::ExternalArray&lt;Ty&gt;::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint32_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2IENK2KL13ExternalArrayI2TyEixE8uint32_t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The read-only array indexing operator.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IEN2KL13ExternalArrayI2TyEixE8uint32_t">
Ty &amp;<code class="descclassname">KL::ExternalArray&lt;Ty&gt;::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint32_t <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2IEN2KL13ExternalArrayI2TyEixE8uint32_t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The read-write array indexing operator.  It returns a modifiable reference to the given element of the array.</p>
</dd></dl>

</div>
<div class="section" id="kl-externalarray-ty">
<h3><code class="samp docutils literal"><span class="pre">KL::ExternalArray&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code><a class="headerlink" href="#kl-externalarray-ty" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Provides the functionality of a external array of the type <code class="samp docutils literal"><em><span class="pre">Ty</span></em></code>, which must itself be a KL built-in or user-defined type.  It allows you to construct a new array from a raw pointer and element count, along with the usual empty and copy constructors and assignment operators.  It provides the following specialized constructors and methods:</p>
<dl class="function">
<dt id="_CPPv213ExternalArrayP2Ty8uint32_t">
<span id="ExternalArray__TyP.uint32_t"></span>KL::ExternalArray&lt;Ty&gt; <code class="descclassname"></code><code class="descname">ExternalArray</code><span class="sig-paren">(</span>Ty *<em>members</em>, uint32_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv213ExternalArrayP2Ty8uint32_t" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Constructs a new external array from a raw pointer and a size (element count).  The external array does <em>not</em> take ownership of the data; it is the responsibility of the extension author to manage the lifecycle of the underlying data and to ensure that it outlives any use of the data anywhere in Fabric Engine.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IENK2KL13ExternalArrayI2TyE4sizeEv">
uint32_t <code class="descclassname">KL::ExternalArray&lt;Ty&gt;::</code><code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2IENK2KL13ExternalArrayI2TyE4sizeEv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns the size (length) of the array.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt>
Ty <em class="property">const</em> &amp;<code class="descclassname">KL::ExternalArray&lt;Ty&gt;::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint32_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em></dt>
<dd><p>The read-only array indexing operator.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt>
Ty &amp;<code class="descclassname">KL::ExternalArray&lt;Ty&gt;::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>uint32_t <em>index</em><span class="sig-paren">)</span></dt>
<dd><p>The read-write array indexing operator.  It returns a modifiable reference to the given element of the array.</p>
</dd></dl>

<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">Unlike KL, there is no checks for array indices when indexing into an array.  It is the responsibility of the programmer to ensure that the array index is within bounds.</p>
</div>
</div>
<div class="section" id="kl-dict-keyty-valuety">
<h3><code class="samp docutils literal"><span class="pre">KL::Dict&lt;</span><em><span class="pre">KeyTy</span></em><span class="pre">,</span> <em><span class="pre">ValueTy</span></em><span class="pre">&gt;`</span></code><a class="headerlink" href="#kl-dict-keyty-valuety" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Provides the functionality of a dictionary that maps keys of type <code class="samp docutils literal"><em><span class="pre">KeyTy</span></em></code> to values of type <code class="samp docutils literal"><span class="pre">ValueTy</span></code>.  <code class="samp docutils literal"><em><span class="pre">KeyTy</span></em></code> must be either a simple type or <code class="code docutils literal"><span class="pre">KL::String</span></code>; <code class="samp docutils literal"><span class="pre">ValueTy</span></code> can be any KL type.  It supports an empty constructor that constructs an empty dictionary, a copy constructor and assignment operator that take a reference to the contents of the other dictionary, as well as the following methods:</p>
<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IENK2KL4DictI5KeyTy7ValueTyE4sizeEv">
uint32_t <code class="descclassname">KL::Dict&lt;KeyTy, ValueTy&gt;::</code><code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2IENK2KL4DictI5KeyTy7ValueTyE4sizeEv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns the size (length) of the array.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IEN2KL4DictI5KeyTy7ValueTyE3hasER5KeyTy">
bool <code class="descclassname">KL::Dict&lt;KeyTy, ValueTy&gt;::</code><code class="descname">has</code><span class="sig-paren">(</span>KeyTy <em class="property">const</em> &amp;<em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2IEN2KL4DictI5KeyTy7ValueTyE3hasER5KeyTy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">true</span></code> if and only if there is a value for the given key in the dictionary.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IENK2KL4DictI5KeyTy7ValueTyEixER5KeyTy">
ValueTy <em class="property">const</em> &amp;<code class="descclassname">KL::Dict&lt;KeyTy, ValueTy&gt;::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>KeyTy <em class="property">const</em> &amp;<em>key</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2IENK2KL4DictI5KeyTy7ValueTyEixER5KeyTy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The read-only dictionary indexing operator.  If there is no value for the given key in the dictionary an exception is thrown.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IEN2KL4DictI5KeyTy7ValueTyE8maybeGetER5KeyTy">
ValueTy <em class="property">const</em> *<code class="descclassname">KL::Dict&lt;KeyTy, ValueTy&gt;::</code><code class="descname">maybeGet</code><span class="sig-paren">(</span>KeyTy <em class="property">const</em> &amp;<em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2IEN2KL4DictI5KeyTy7ValueTyE8maybeGetER5KeyTy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Get a pointer to the value corresponding to the given key.  If there is no value for the given key, this method returns <code class="docutils literal"><span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IEN2KL4DictI5KeyTy7ValueTyEixER5KeyTy">
ValueTy &amp;<code class="descclassname">KL::Dict&lt;KeyTy, ValueTy&gt;::</code><code class="descname">operator[]</code><span class="sig-paren">(</span>KeyTy <em class="property">const</em> &amp;<em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2IEN2KL4DictI5KeyTy7ValueTyEixER5KeyTy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The read-write array indexing operator.  It returns a mutable (read-write) reference to the value for the key in the dictionary.  If there is no value for the key, a new value is created for the key.  The initial value of the new value is the default value for <code class="samp docutils literal"><span class="pre">ValueTy</span></code>.</p>
</dd></dl>

<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IEN2KL4DictI5KeyTy7ValueTyE3getER5KeyTyR7ValueTy">
ValueTy &amp;<code class="descclassname">KL::Dict&lt;KeyTy, ValueTy&gt;::</code><code class="descname">get</code><span class="sig-paren">(</span>KeyTy <em class="property">const</em> &amp;<em>key</em>, ValueTy <em class="property">const</em> &amp;<em>defaultValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2IEN2KL4DictI5KeyTy7ValueTyE3getER5KeyTyR7ValueTy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Get the value for the given key from the dictionary, returning an mutable (read-write) reference to the value.  If there is no value for the key, a new value is created whose value is <code class="docutils literal"><span class="pre">defaultValue</span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">References returned from the array indexing operators should be considered temporary and should not be stored in other variables.  Methods that potential modify the dictionary can cause the references to become invalid, leading to programming errors.</p>
</div>
<dl class="function">
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IEN2KL4DictI5KeyTy7ValueTyE5beginEv">
KL::Dict&lt;KeyTy, ValueTy&gt;::iterator <code class="descclassname">KL::Dict&lt;KeyTy, ValueTy&gt;::</code><code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2IEN2KL4DictI5KeyTy7ValueTyE5beginEv" title="この定義へのパーマリンク">¶</a></dt>
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IEN2KL4DictI5KeyTy7ValueTyE3endEv">
KL::Dict&lt;KeyTy, ValueTy&gt;::iterator <code class="descclassname">KL::Dict&lt;KeyTy, ValueTy&gt;::</code><code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2IEN2KL4DictI5KeyTy7ValueTyE3endEv" title="この定義へのパーマリンク">¶</a></dt>
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IENK2KL4DictI5KeyTy7ValueTyE5beginEv">
KL::Dict&lt;KeyTy, ValueTy&gt;::const_iterator <code class="descclassname">KL::Dict&lt;KeyTy, ValueTy&gt;::</code><code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2IENK2KL4DictI5KeyTy7ValueTyE5beginEv" title="この定義へのパーマリンク">¶</a></dt>
<dt>
template&lt;&gt;</dt>
<dt id="_CPPv2IENK2KL4DictI5KeyTy7ValueTyE3endEv">
KL::Dict&lt;KeyTy, ValueTy&gt;::const_iterator <code class="descclassname">KL::Dict&lt;KeyTy, ValueTy&gt;::</code><code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2IENK2KL4DictI5KeyTy7ValueTyE3endEv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The iteration interface for dictionaries.  Please refer to the <code class="file docutils literal"><span class="pre">EDKDicts.cpp</span></code> example
in the <code class="file docutils literal"><span class="pre">$FABRIC_DIR/Samples/EDK/EDKDicts</span></code> folder for an example of dictionary
iteration in the EDK.</p>
</dd></dl>

</div>
<div class="section" id="kl-object">
<h3><code class="code docutils literal"><span class="pre">KL::Object</span></code><a class="headerlink" href="#kl-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <code class="code docutils literal"><span class="pre">KL::Object</span></code> type is the equivalent of the KL <code class="code docutils literal"><span class="pre">Object</span></code> type that refers to an arbitrary object.  It supports an empty constructor (which constructs a null object reference), a copy constructor and an assignment operator (taking a reference to the other object) as well as the <code class="docutils literal"><span class="pre">==</span></code> and <code class="docutils literal"><span class="pre">!=</span></code> comparison operators.</p>
</div>
</div>
<div class="section" id="user-defined-types">
<span id="types-user-defined"></span><h2>User-Defined Types<a class="headerlink" href="#user-defined-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The KL <code class="code docutils literal"><span class="pre">struct</span></code>, <code class="code docutils literal"><span class="pre">interface</span></code> and <code class="code docutils literal"><span class="pre">object</span></code> types are user-defined types.  They may be defined by the KL source files of the extension or one of the other extensions that the extension requires.</p>
<p>User-defined types have C++ equivalents defined for them in the header generated by the <strong class="command">kl2edk</strong> tool.  The following section detail usage of these C++ equivalent types.</p>
<div class="section" id="structures">
<span id="eag-types-structs"></span><h3>Structures<a class="headerlink" href="#structures" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>KL structures (defined using the KL <code class="code docutils literal"><span class="pre">struct</span></code> keyword) are be directly represented by C++ structures.  Each member of the KL structure is provided as a structure member in C++ with exactly the corresponding C++ type.  You can therefore reference the members of an instance of the structure using the usual <code class="code docutils literal"><span class="pre">.</span></code> operation, as well as performing all the other usual C++ structure operations.</p>
<div class="section" id="mapping-kl-structures-to-third-party-api-structures">
<h4>Mapping KL Structures to Third-Party API Structures<a class="headerlink" href="#mapping-kl-structures-to-third-party-api-structures" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Since the generated C++ KL structure maps directly to a plain C++ structure with the KL types for its members, it is possible to pointer-cast the KL structure to another structure using the <code class="code docutils literal"><span class="pre">reinterpret_cast</span></code> operator in C++.  However, you must ensure the following about the target structure:</p>
<ul class="simple">
<li>The structure must only contain simple KL types or other structures containing simple KL types.  For a list of C++ types equivalent to the simple KL types, see <a class="reference internal" href="#types-simple-equivalent"><span class="std std-ref">Equivalences for Simple Types</span></a>.</li>
<li>The order of the members in the structure must be exactly the same in KL and in C++</li>
<li>The structure must use the default C++ alignment for the structure and its members.</li>
</ul>
</div>
</div>
<div class="section" id="interfaces">
<span id="eag-types-interfaces"></span><h3>Interfaces<a class="headerlink" href="#interfaces" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>For each interface defined in the KL code there will be a C++ equivalent with the same name defined in the generated header.</p>
<p>In the C++ class generated for the interface the methods of the interface are provided through the <code class="samp docutils literal"><em><span class="pre">interface</span></em><span class="pre">.</span><em><span class="pre">methodName</span></em><span class="pre">(</span><em><span class="pre">arg</span></em><span class="pre">,</span> <em><span class="pre">arg</span></em><span class="pre">,</span> <span class="pre">...)</span></code> call.</p>
<p>Additionally, the C++ class provides:</p>
<ul class="simple">
<li>An empty constructor that constructs a null interface reference</li>
<li>A copy constructor and an assignment operator that copy a reference to the other interface</li>
<li>The <code class="docutils literal"><span class="pre">==</span></code> and <code class="docutils literal"><span class="pre">!=</span></code> comparison operators that compare for interfaces to point to the same object</li>
<li>A conversion to the C++ type <code class="code docutils literal"><span class="pre">bool</span></code> as well as the <code class="code docutils literal"><span class="pre">operator</span> <span class="pre">!</span></code> that can be used for checks for the interface reference being non-null or null</li>
</ul>
<p>For example:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="c1">// KL code</span>

<span class="kr">interface</span> <span class="nx">MyInt</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">foo</span><span class="p">();</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">callIntMethod</span><span class="p">(</span><span class="nx">MyInt</span> <span class="nx">myInt</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;CallIntMethod&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>then the corresponding C++ definition for <code class="code docutils literal"><span class="pre">CallIntMethod</span></code> should be:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// C++ code</span>

<span class="n">FABRIC_EXT_EXPORT</span> <span class="kt">void</span> <span class="nf">CallIntMethod</span><span class="p">(</span>
  <span class="n">Fabric</span><span class="o">::</span><span class="n">EDK</span><span class="o">::</span><span class="n">KL</span><span class="o">::</span><span class="n">myInt</span><span class="o">::</span><span class="n">INParam</span> <span class="n">myInt</span>
  <span class="p">)</span>
<span class="p">{</span>
  <span class="n">Fabric</span><span class="o">::</span><span class="n">EDK</span><span class="o">::</span><span class="n">KL</span><span class="o">::</span><span class="n">Float32</span> <span class="n">result</span> <span class="o">=</span> <span class="n">myInt</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>
  <span class="n">Fabric</span><span class="o">::</span><span class="n">EDK</span><span class="o">::</span><span class="n">report</span><span class="p">(</span><span class="s">&quot;myInt.foo() returned %f&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="objects">
<span id="eag-types-objects"></span><h3>Objects<a class="headerlink" href="#objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>For each object defined in the KL code there will be a C++ equivalent with the same name defined in the generated header.</p>
<p>The members of the object are accessed through the <code class="samp docutils literal"><em><span class="pre">object</span></em><span class="pre">-&gt;</span><em><span class="pre">memberName</span></em></code> operation.  All of the members of the KL structure are provided through this operation.</p>
<p>The methods of the object that belong to an interface that the object implements are provided through the <code class="samp docutils literal"><em><span class="pre">object</span></em><span class="pre">.</span><em><span class="pre">methodName</span></em><span class="pre">(</span><em><span class="pre">arg</span></em><span class="pre">,</span> <em><span class="pre">arg</span></em><span class="pre">,</span> <span class="pre">...)</span></code> call.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">There is currently no way to call methods on the object that are not part of an implemented interface.</p>
</div>
<ul class="simple">
<li>An empty constructor that constructs a null object reference</li>
<li>A static method <code class="samp docutils literal"><em><span class="pre">objectType</span></em><span class="pre">::Create()</span></code> constructs a new Object of type <code class="samp docutils literal"><span class="pre">objectType</span></code> and returns a reference to it</li>
<li>A copy constructor and an assignment operator that copy a reference to the other object</li>
<li>The <code class="docutils literal"><span class="pre">==</span></code> and <code class="docutils literal"><span class="pre">!=</span></code> comparison operators that compare for objects to point to the same object</li>
<li>A conversion to the C++ type <code class="code docutils literal"><span class="pre">bool</span></code> as well as the <code class="code docutils literal"><span class="pre">operator</span> <span class="pre">!</span></code> that can be used for checks for the object reference being non-null or null</li>
</ul>
<p>For example:</p>
<div class="highlight-kl"><div class="highlight"><pre><span></span><span class="c1">// KL code</span>

<span class="kr">interface</span> <span class="nx">MyInt</span> <span class="p">{</span>
  <span class="kr">Float32</span> <span class="nx">foo</span><span class="p">();</span>
<span class="p">};</span>

<span class="kr">object</span> <span class="nx">MyObj</span> <span class="o">:</span> <span class="nx">MyInt</span> <span class="p">{</span>
  <span class="kr">Byte</span> <span class="nx">b</span><span class="p">;</span>
  <span class="kr">String</span> <span class="nx">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">displayObjectMembers</span><span class="p">(</span><span class="nx">MyObj</span> <span class="nx">myObj</span><span class="p">)</span> <span class="o">=</span> <span class="s2">&quot;DisplayObjectMembers&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>then the corresponding C++ definition for <code class="code docutils literal"><span class="pre">DisplayObjectMembers</span></code> should be:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// C++ code</span>

<span class="n">FABRIC_EXT_EXPORT</span> <span class="kt">void</span> <span class="nf">DisplayObjectMembers</span><span class="p">(</span>
  <span class="n">Fabric</span><span class="o">::</span><span class="n">EDK</span><span class="o">::</span><span class="n">KL</span><span class="o">::</span><span class="n">MyObj</span><span class="o">::</span><span class="n">INParam</span> <span class="n">myObj</span>
  <span class="p">)</span>
<span class="p">{</span>
  <span class="n">Fabric</span><span class="o">::</span><span class="n">EDK</span><span class="o">::</span><span class="n">report</span><span class="p">(</span>
    <span class="s">&quot;myObj.b=%u myObj.s=%s&quot;</span><span class="p">,</span>
    <span class="kt">unsigned</span><span class="p">(</span><span class="n">myObj</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span>
    <span class="n">myObj</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span>
    <span class="p">);</span>
  <span class="n">Fabric</span><span class="o">::</span><span class="n">EDK</span><span class="o">::</span><span class="n">KL</span><span class="o">::</span><span class="n">Float32</span> <span class="n">result</span> <span class="o">=</span> <span class="n">myObj</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>
  <span class="n">Fabric</span><span class="o">::</span><span class="n">EDK</span><span class="o">::</span><span class="n">report</span><span class="p">(</span><span class="s">&quot;myObj.foo() returned %f&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Refer to the EDKObjects sample located in <code class="docutils literal"><span class="pre">$FABRIC_DIR/Samples/EDK/EDKObjects</span></code> for a detailed example of exposing object functionality using the EDK.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/FE_logo_211_37.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">Types and Extensions</a><ul>
<li><a class="reference internal" href="#simple-types">Simple Types</a><ul>
<li><a class="reference internal" href="#equivalences-for-simple-types">Equivalences for Simple Types</a></li>
<li><a class="reference internal" href="#the-kl-datawrapper-ty-and-kl-constdatawrapper-ty-templates">The <code class="samp docutils literal"><span class="pre">KL::DataWrapper&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code> and <code class="samp docutils literal"><span class="pre">KL::ConstDataWrapper&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code> Templates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#complex-types">Complex Types</a><ul>
<li><a class="reference internal" href="#kl-string"><code class="code docutils literal"><span class="pre">KL::String</span></code></a></li>
<li><a class="reference internal" href="#kl-variablearray-ty"><code class="samp docutils literal"><span class="pre">KL::VariableArray&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code></a></li>
<li><a class="reference internal" href="#kl-fixedarray-ty-size"><code class="samp docutils literal"><span class="pre">KL::FixedArray&lt;</span><em><span class="pre">Ty</span></em><span class="pre">,</span> <em><span class="pre">size</span></em><span class="pre">&gt;</span></code></a></li>
<li><a class="reference internal" href="#kl-externalarray-ty"><code class="samp docutils literal"><span class="pre">KL::ExternalArray&lt;</span><em><span class="pre">Ty</span></em><span class="pre">&gt;</span></code></a></li>
<li><a class="reference internal" href="#kl-dict-keyty-valuety"><code class="samp docutils literal"><span class="pre">KL::Dict&lt;</span><em><span class="pre">KeyTy</span></em><span class="pre">,</span> <em><span class="pre">ValueTy</span></em><span class="pre">&gt;`</span></code></a></li>
<li><a class="reference internal" href="#kl-object"><code class="code docutils literal"><span class="pre">KL::Object</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#user-defined-types">User-Defined Types</a><ul>
<li><a class="reference internal" href="#structures">Structures</a><ul>
<li><a class="reference internal" href="#mapping-kl-structures-to-third-party-api-structures">Mapping KL Structures to Third-Party API Structures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interfaces">Interfaces</a></li>
<li><a class="reference internal" href="#objects">Objects</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="kl2edk.html"
                        title="前の章へ">The <strong class="command">kl2edk</strong> Utility</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="cconv.html"
                        title="次の章へ">Calling Convention for Exported Functions</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/ExtensionAuthoringGuide/types.txt"
            rel="nofollow">ソースコードを表示</a></li>
    <li><a href="http://docs.fabric-engine.com/FabricEngine/latest/HTML/ExtensionAuthoringGuide/types.html"
              rel="nofollow">原文公式ページへ移動 (goto official page)</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="cconv.html" title="Calling Convention for Exported Functions"
             >次へ</a> |</li>
        <li class="right" >
          <a href="kl2edk.html" title="The kl2edk Utility"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Fabric Engine 2.3.0 Unofficial Documentation (ja)</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >エクステンション・オーサリングガイド</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2010-2016 Fabric Software Inc.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1 で生成しました。
    </div>
  </body>
</html>